# ã‚ˆãã‚ã‚‹è³ªå•ã¨å›ç­”

<p class="description">ç‰¹å®šã®å•é¡Œã§ç«‹ã¡å¾€ç”Ÿã—ã¦ã„ã¾ã™ã‹ï¼Ÿ ã‚ˆãã‚ã‚‹è³ªå•ã§ã“ã‚Œã‚‰ã®ã‚ˆãã‚ã‚‹å•é¡Œã®ã„ãã¤ã‹ã‚’æœ€åˆã«ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>

ã‚‚ã—æ¢ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã¾ã è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ [Spectrum](https://spectrum.chat/material-ui)ã«ã‚ã‚‹æˆ‘ã€…ã®ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã«è³ªå•ãŒã§ãã¾ã™ ä½¿ã„æ–¹ã®è³ªå•ã‚„ãã®ä»–é‡è¦ã§ã¯ãªã„å•é¡Œã¯ã€Github issuesã§ã¯ãªã[StackOverflow](https://stackoverflow.com/questions/tagged/material-ui)ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚ `material-ui`ã¨ã„ã†StackOverflowã‚¿ã‚°ãŒã‚ã‚Šã¾ã™ã€‚ è³ªå•ã«ã¯ãã®ã‚¿ã‚°ã‚’ã¤ã‘ã¦ãã ã•ã„ã€‚

## productionãƒ“ãƒ«ãƒ‰ã§ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæ­£ã—ããƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œãªã„ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ

ã“ã‚Œã¯ã€ã‚³ãƒ¼ãƒ‰ãŒproduction bundleã«å…¥ã£ãŸå¾Œã«ã‚¯ãƒ©ã‚¹åãŒç«¶åˆã™ã‚‹ãŸã‚ã«ç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹nÂ°1ã®å•é¡Œã§ã™ã€‚ Material-UIãŒæ©Ÿèƒ½ã™ã‚‹ãŸã‚ã«ã¯ã€`className`ãƒšãƒ¼ã‚¸ä¸Šã®ã™ã¹ã¦ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å€¤ã¯ã€[ã‚¯ãƒ©ã‚¹åã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿](/styles/advanced/#class-names)ã®å˜ä¸€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ã«ã¯ã€ãƒšãƒ¼ã‚¸ä¸Šã®ã™ã¹ã¦ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’åˆæœŸåŒ–ã—ã¦ã€ãã‚Œã‚‰ã®é–“ã®**ã‚¯ãƒ©ã‚¹åã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒ1ã¤ã ã‘**å­˜åœ¨ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã•ã¾ã–ã¾ãªã‚·ãƒŠãƒªã‚ªã§ã€èª¤ã£ã¦2ã¤ã®ã‚¯ãƒ©ã‚¹åã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ãªã‚‹äº‹ä¾‹

- èª¤ã£ã¦Material-UIã®2ã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’**bundle**ã—ã¦ã—ã¾ã£ã¦ã„ã‚‹å ´åˆã€ ä¾å­˜é–¢ä¿‚ãŒMaterial-UIã‚’å¯¾ã®ä¾å­˜é–¢ä¿‚ã¨ã—ã¦æ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™
- Reactãƒ„ãƒªãƒ¼ã®**ã‚µãƒ–ã‚»ãƒƒãƒˆ**ã«`StylesProvider`ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆ
- ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã„ã¦ã€ãã‚ŒãŒåŸå› ã§è¤‡æ•°ã®ã‚¯ãƒ©ã‚¹åã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä½œæˆã•ã‚Œã‚‹ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’åˆ†å‰²ã—ã¦ã„ã‚‹å ´åˆã€‚

> If you are using webpack with the [SplitChunksPlugin](https://webpack.js.org/plugins/split-chunks-plugin/), try configuring the [`runtimeChunk` setting under `optimizations`](https://webpack.js.org/configuration/optimization/#optimization-runtimechunk).

å…¨ä½“ã¨ã—ã¦ã€å„Material-UIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ„ãƒªãƒ¼ã®æœ€ä¸Šéƒ¨ã«ã‚ã‚‹[`StylesProvider`](/styles/api/#stylesprovider)ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§Wrapã—ã€**ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ„ãƒªãƒ¼é–“ã§å…±æœ‰ã•ã‚Œã‚‹å˜ä¸€ã®ã‚¯ãƒ©ã‚¹åã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§**ã€ã“ã®å•é¡Œã‚’ç°¡å˜ã«è§£æ±ºã§ãã¾ã™ã€‚

## ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ãã¨ã€fixed positionã•ã‚ŒãŸDOMãŒç§»å‹•ã™ã‚‹ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ

ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã‹ã‚Œã‚‹ã¨ã™ãã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚ ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒå”¯ä¸€ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§ã‚ã‚‹ã¹ãå ´åˆã€backgroundã¨ã®é€£å‹•ã‚’é˜²ãã¾ã™ã€‚ã—ã‹ã—ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’å–ã‚Šé™¤ãã“ã¨ã§**fixed positionã•ã‚ŒãŸDOM**ã‚’å‹•ã‹ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ ã“ã®å ´åˆã€Material-UIã«ã“ã‚Œã‚‰ã®DOMã‚’å‡¦ç†ã™ã‚‹ã‚ˆã†ã«ä¼ãˆã‚‹ãŸã‚ã«ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãª `.mui-fixed`ã‚¯ãƒ©ã‚¹åã‚’é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## æ³¢ç´‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ç„¡åŠ¹ã«ã™ã‚‹æ–¹æ³•ã¯ï¼Ÿ

æ³¢ç´‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€BaseButtonã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‹ã‚‰ã®ã¿ç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚ ãƒ†ãƒ¼ãƒã«æ¬¡ã®ã‚ˆã†ã«æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€æ³¢ç´‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ç„¡åŠ¹ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```js
import { createMuiTheme } from '@material-ui/core';

const theme = createMuiTheme({
  props: {
    // Name of the component âš›ï¸
    MuiButtonBase: {
      // The properties to apply
      disableRipple: true, // No more ripple, on the whole application ğŸ’£!
    },
  },
});
```

## How can I disable transitions globally?

You can disable transitions globally by providing the following in your theme:

```js
import { createMuiTheme } from '@material-ui/core';

const theme = createMuiTheme({
  transitions: {
    // So we have `transition: none;` everywhere
    create: () => 'none',
  },
});
```

ãƒ†ã‚¹ãƒˆä¸­ã‚„ãƒ­ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ãªã©ã§ã€æ¡ä»¶ä»˜ãã§ã“ã®å‹•ä½œã‚’æœ‰åŠ¹ã«ã—ãŸã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å ´åˆã¯ã€ãƒ†ãƒ¼ãƒã®å€¤ã‚’å‹•çš„ã«å¤‰æ›´ã§ãã¾ã™ã€‚

You can go one step further by disabling all the transitions, animations and the ripple effect:

```js
import { createMuiTheme } from '@material-ui/core';

const theme = createMuiTheme({
  transitions: {
    // So we have `transition: none;` everywhere
    create: () => 'none',
  },
  overrides: {
    // Name of the component âš›ï¸
    MuiCssBaseline: {
      // Name of the rule
      '@global': {
        '*, *::before, *::after': {
          transition: 'none !important',
          animation: 'none !important',
        },
      },
    },
  },
  props: {
    // Name of the component âš›ï¸
    MuiButtonBase: {
      // The properties to apply
      disableRipple: true, // No more ripple, on the whole application!
    },
  },
});
```

## ã‚¢ãƒ—ãƒªã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®šã™ã‚‹ã«ã¯JSSã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿ

No, it's not required. But this dependenency comes built in, so carries no additional bundle size overhead.

ã—ã‹ã—ã€ãŠãã‚‰ãã™ã§ã«åˆ¥ã®ã‚¹ã‚¿ã‚¤ãƒ«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã„ãã¤ã‹ã®Material-UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’è¿½åŠ ã—ã¦ã„ã‚‹ã€ ã¾ãŸã¯ã™ã§ã«åˆ¥ã®APIã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã«ã¯ã€æ–°ã—ã„ã‚‚ã®ã‚’å­¦ã³ãŸãã¯ãªã„ã§ã—ã‚‡ã†ï¼Ÿ ãã®å ´åˆã¯ã€[ã‚¹ã‚¿ã‚¤ãƒ«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç›¸äº’é‹ç”¨](/guides/interoperability/)ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã€Material-UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’åˆ¥ã®ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚¹ã‚¿ã‚¤ãƒ«å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã„ã‹ã«ç°¡å˜ã§ã‚ã‚‹ã‹ã‚’ç¤ºã—ã¾ã™ã€‚

## When should I use inline-style vs CSS?

çµŒé¨“å‰‡ã¨ã—ã¦ã€å‹•çš„styleãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ã¯inline-styleã®ã¿ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ CSSã®ä»£æ›¿æ‰‹æ®µã¯ã€æ¬¡ã®ã‚ˆã†ãªã‚ˆã‚Šå¤šãã®åˆ©ç‚¹ã‚’æä¾›ã—ã¾ã™ã€‚

- auto-prefixing
- ãƒ‡ãƒãƒƒã‚¯ã®ã—ã‚„ã™ã•
- ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¯ã‚¨ãƒª
- keyframes

## react-routerã®ä½¿ã„æ–¹ã¯ï¼Ÿ

ç§é”ã¯[ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£è£½ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ©ã‚¤ãƒ–ãƒ©ãƒª](/components/buttons/#third-party-routing-library)ã§`ButtonBase`ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ä½¿ã„æ–¹ã‚’ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã—ã¾ã—ãŸã€‚ å¤šãã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å†…éƒ¨çš„ã«ä½¿ã£ã¦ã„ã¾ã™ï¼š`Button`, `MenuItem`, `<ListItem button />`, `Tab` ãã‚Œã‚‰ã®ä¾‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚

## ã©ã†ã‚„ã£ã¦DOMè¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã‹ï¼Ÿ

All Material-UI components that should render something in the DOM forward their ref to the underlying DOM component. This means that you can get DOM elements by reading the ref attached to Material-UI components:

```jsx
// or a ref setter function
const ref = React.createRef();
// render
<Button ref={ref} />;
// usage
const element = ref.current;
```

If you're not sure if the Material-UI component in question forwards its ref you can check the API documentation under "Props" e.g. the [Button API](/api/button/#props) includes

> The ref is forwarded to the root element.

indicating that you can access the DOM element with a ref.

## I have several instances of styles on the page

If you are seeing a warning message in the console like the one below, you probably have several instances of `@material-ui/styles` initialized on the page.

> It looks like there are several instances of `@material-ui/styles` initialized in this application. This may cause theme propagation issues, broken class names, specificity issues, and makes your application bigger without a good reason.

### Possible reasons

There are several common reasons for this to happen:

- You have another `@material-ui/styles` library somewhere in your dependencies.
- You have a monorepo structure for your project (e.g, lerna, yarn workspaces) and `@material-ui/styles` module is a dependency in more than one package (this one is more or less the same as the previous one).
- You have several applications that are using `@material-ui/styles` running on the same page (e.g., several entry points in webpack are loaded on the same page).

### Duplicated module in node_modules

If you think that the issue is in duplicated @material-ui/styles module somewhere in your dependencies, there are several ways to check this. You can use `npm ls @material-ui/styles`, `yarn list @material-ui/styles` or `find -L ./node_modules | grep /@material-ui/styles/package.json` commands in your application folder.

If none of these commands identified the duplication, try analyzing your bundle for multiple instances of @material-ui/styles. You can just check your bundle source, or use a tool like [source-map-explorer](https://github.com/danvk/source-map-explorer) or [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer).

If you identified that duplication is the issue that you are encountering there are several things you can try to solve it:

If you are using npm you can try running `npm dedupe`. This command searches the local dependencies and tries to simplify the structure by moving common dependencies further up the tree.

If you are using webpack, you can change the way it will [resolve](https://webpack.js.org/configuration/resolve/#resolve-modules) the @material-ui/styles module. You can overwrite the default order in which webpack will look for your dependencies and make your application node_modules more prioritized than default node module resolution order:

```diff
  resolve: {
+   alias: {
+     "@material-ui/styles": path.resolve(appFolder, "node_modules", "@material-ui/styles"),
+   }
  }
```

### Usage with Lerna

One possible fix to get @material-ui/styles to run in a Lerna monorepo across packages, is to [hoist](https://github.com/lerna/lerna/blob/master/doc/hoist.md) shared dependencies to the root of your monorepo file. Try running the bootstrap option with the --hoist flag.

```sh
lerna bootstrap --hoist
```

Alternatively, you can remove @material-ui/styles from your package.json file and hoist it manually to your top-level package.json file.

Example of a package.json file in a Lerna root folder

```json
{
  "name": "my-monorepo",
  "devDependencies": {
    "lerna": "latest"
  },
  "dependencies": {
    "@material-ui/styles": "^4.0.0"
  },
  "scripts": {
    "bootstrap": "lerna bootstrap",
    "clean": "lerna clean",
    "start": "lerna run start",
    "build": "lerna run build"
  }
}
```

### Running multiple applications on one page

If you have several applications running on one page, consider using one @material-ui/styles module for all of them. If you are using webpack, you can use [CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/) to create an explicit [vendor chunk](https://webpack.js.org/plugins/commons-chunk-plugin/#explicit-vendor-chunk), that will contain the @material-ui/styles module:

```diff
  module.exports = {
    entry: {
+     vendor: ["@material-ui/styles"],
      app1: "./src/app.1.js",
      app2: "./src/app.2.js",
    },
    plugins: [
+     new webpack.optimize.CommonsChunkPlugin({
+       name: "vendor",
+       minChunks: Infinity,
+     }),
    ]
  }
```

## My App doesn't render correctly on the server

If it doesn't work, in 99% of cases it's a configuration issue. A missing property, a wrong call order, or a missing component. We are very strict about configuration, and the best way to find out what's wrong is to compare your project to an already working setup, check out our [reference implementations](/guides/server-rendering/#reference-implementations), bit by bit.

### CSS works only on first load then is missing

The CSS is only generated on the first load of the page. Then, the CSS is missing on the server for consecutive requests.

#### Action to Take

We rely on a cache, the sheets manager, to only inject the CSS once per component type (if you use two buttons, you only need the CSS of the button one time). You need to create **a new `sheets` instance for each request**.

*example of fix:*

```diff
-// Create a sheets instance.
-const sheets = new ServerStyleSheets();

function handleRender(req, res) {

+ // Create a sheets instance.
+ const sheets = new ServerStyleSheets();

  //â€¦

  // Render the component to a string.
  const html = ReactDOMServer.renderToString(
```

### React class name hydration mismatch

There is a class name mismatch between the client and the server. It might work for the first request. Another symptom is that the styling changes between initial page load and the downloading of the client scripts.

#### Action to Take

The class names value relies on the concept of [class name generator](/styles/advanced/#class-names). The whole page needs to be rendered with **a single generator**. This generator needs to behave identically on the server and on the client. For instance:

- You need to provide a new class name generator for each request. But you shouldn't share a `createGenerateClassName()` between different requests:

*example of fix:*

```diff
-// Create a new class name generator.
-const generateClassName = createGenerateClassName();

function handleRender(req, res) {

+ // Create a new class name generator.
+ const generateClassName = createGenerateClassName();

  //â€¦

  // Render the component to a string.
  const html = ReactDOMServer.renderToString(
```

- You need to verify that your client and server are running the **exactly the same version** of Material-UI. It is possible that a mismatch of even minor versions can cause styling problems. To check version numbers, run `npm list @material-ui/core` in the environment where you build your application and also in your deployment environment.
    
    You can also ensure the same version in different environments by specifying a specific MUI version in the dependencies of your package.json.

*example of fix (package.json):*

```diff
  "dependencies": {
    ...

-   "@material-ui/core": "^4.0.0",
+   "@material-ui/core": "4.0.0",
    ...
  },
```

- You need to make sure that the server and the client share the same `process.env.NODE_ENV` value.

## ç§ãŒè¦‹ã¦ã„ã‚‹è‰²ã¨ã“ã®ã‚µã‚¤ãƒˆã§è¦‹ã¦ã„ã‚‹è‰²ãŒé•ã†ã®ã¯ãªãœã§ã™ã‹ï¼Ÿ

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚µã‚¤ãƒˆã¯ã‚«ã‚¹ã‚¿ãƒ ãƒ†ãƒ¼ãƒã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚ ã—ãŸãŒã£ã¦ã€ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆãŒã‚ã‚‹Material-UIãŒæä¾›ã—ã¦ã„ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ†ãƒ¼ãƒã¯ç•°ãªã‚Šã¾ã™ã€‚ ãƒ†ãƒ¼ãƒã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã«ã¤ã„ã¦å­¦ã¶ã«ã¯ã€ã“ã®[ãƒšãƒ¼ã‚¸](/customization/theming/)ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## Material-UIã¯æœ€é«˜ã§ã™ã€‚ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’æ”¯æ´ã™ã‚‹ã«ã¯ã©ã®ã‚ˆã†ã«ã§ãã¾ã™ã‹ï¼Ÿ

Material-UIã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹æ–¹æ³•ã¯ãŸãã•ã‚“ã‚ã‚Šã¾ã™ã€‚

- [ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://github.com/mui-org/material-ui/tree/master/docs)ã‚’æ”¹å–„ã™ã‚‹ 
- ä»–ã®äººãŒå§‹ã‚ã‚‹ã®ã‚’æ‰‹ä¼ã†
- [ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å¸ƒæ•™ã™ã‚‹](https://twitter.com/MaterialUI) 
- [StackOverflow](https://stackoverflow.com/questions/tagged/material-ui)ã‚„[Spectrum](https://spectrum.chat/material-ui)ã§è³ªå•ã«ç­”ãˆã‚‹

å•†ç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§Material-UIã‚’ä½¿ç”¨ã—ã¦ã„ã¦ã€ã‚¹ãƒãƒ³ã‚µãƒ¼ã«ãªã‚‹ã“ã¨ã«ã‚ˆã£ã¦ãã®ç¶™ç¶šçš„ãªé–‹ç™ºã‚’æ”¯æ´ã—ãŸã„å ´åˆã¯ã€ ã‚ã‚‹ã„ã¯ã‚µãƒ–ã‚„è¶£å‘³ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§**ã‚¹ãƒãƒ³ã‚µãƒ¼**ã«ãªã‚ŠãŸã„å ´åˆã¯ã€[OpenCollective](https://opencollective.com/material-ui)ã‚’ä½¿ã£ã¦è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

é›†ã‚ã‚‰ã‚ŒãŸè³‡é‡‘ã¯ã™ã¹ã¦é€éçš„ã«ç®¡ç†ã•ã‚Œã€ã‚¹ãƒãƒ³ã‚µãƒ¼ã¯READMEã¨Material-UIã®ãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸ã§è¡¨å½°ã•ã‚Œã¾ã™ã€‚

## Why does component X require a DOM node in a prop instead of a ref object?

Components like the [Portal](/api/portal/#props) or [Popper](/api/popper/#props) require a DOM node in the `container` or `anchorEl` prop respectively. It seems convenient to simply pass a ref object in those props and let Material-UI access the current value. This works in a simple scenario:

```jsx
function App() {
  const container = React.useRef(null);

  return (
    <div className="App">
      <Portal container={container}>
        <span>portaled children</span>
      </Portal>
      <div ref={container} />
    </div>
  );
}
```

where `Portal` would only mount the children into the container when `container.current` is available. Here is a naive implementation of Portal:

```jsx
function Portal({ children, container }) {
  const [node, setNode] = React.useState(null);

  React.useEffect(() => {
    setNode(container.current);
  }, [container]);

  if (node === null) {
    return null;
  }
  return ReactDOM.createPortal(children, node);
}
```

With this simple heuristic `Portal` might re-render after it mounts because refs are up-to-date before any effects run. However, just because a ref is up-to-date doesn't mean it points to a defined instance. If the ref is attached to a ref forwarding component it is not clear when the DOM node will be available. In the above example the `Portal` would run run an effect once but might not re-render because `ref.current` is still `null`. This is especially apparent for React.lazy components in Suspense. The above implementation could also not account for a change in the DOM node.

This is why we require a prop with the actual DOM node so that React can take care of determining when the `Portal` should re-render:

```jsx
function App() {
  const [container, setContainer] = React.useState(null);
  const handleRef = React.useCallback(instance => setContainer(instance), [setContainer])

  return (
    <div className="App">
      <Portal container={container}>
        <span>Portaled</span>
      </Portal>
      <div ref={handleRef} />
    </div>
  );
}
```