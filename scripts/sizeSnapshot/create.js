const fse = require('fs-extra');
const lodash = require('lodash');
const path = require('path');
const yargs = require('yargs');
const Piscina = require('piscina');
const os = require('os');
const { getWebpackEntries } = require('./webpack.config');

const MAX_CONCURRENCY = Math.min(8, os.cpus().length);

const workspaceRoot = path.join(__dirname, '../../');
const snapshotDestPath = path.join(workspaceRoot, 'size-snapshot.json');

/**
 * @param {object} snapshot snapshot generated by rollup-plugin-size-snapshot
 * @returns {object} size snapshot with the same format as a snapshot from size-limit
 */
function normalizeRollupSnapshot(snapshot) {
  return { parsed: snapshot.minified, gzip: snapshot.gzipped };
}

async function getRollupSize(snapshotPath) {
  const rollupSnapshot = await fse.readJSON(snapshotPath);

  return Object.entries(rollupSnapshot).map(([bundlePath, snapshot]) => [
    // path in the snapshot is relative the snapshot itself
    path
      .relative(workspaceRoot, path.join(path.dirname(snapshotPath), bundlePath))
      // Ensure original ID when the package was located in `packages/material-ui/`
      .replace('mui-material', 'material-ui'),
    normalizeRollupSnapshot(snapshot),
  ]);
}

/**
 * creates size snapshot for every bundle that built with webpack
 */
async function getWebpackSizes(webpackEnvironment) {
  const worker = new Piscina({
    filename: require.resolve('./worker'),
    maxThreads: MAX_CONCURRENCY,
  });
  await fse.mkdirp(path.join(__dirname, 'build'));

  const entries = await getWebpackEntries();

  const sizeArrays = await Promise.all(
    entries.map((entry, index) =>
      worker.run({ entry, webpackEnvironment, index, total: entries.length }),
    ),
  );

  return sizeArrays.flat();
}

async function run(argv) {
  const { analyze, accurateBundles } = argv;

  const rollupBundles = [path.join(workspaceRoot, 'packages/mui-material/size-snapshot.json')];
  const bundleSizes = lodash.fromPairs([
    ...(await getWebpackSizes({ analyze, accurateBundles })),
    ...lodash.flatten(await Promise.all(rollupBundles.map(getRollupSize))),
  ]);

  await fse.writeJSON(snapshotDestPath, bundleSizes, { spaces: 2 });
}

yargs
  .command({
    command: '$0',
    description: 'Saves a size snapshot in size-snapshot.json',
    builder: (command) => {
      return command
        .option('analyze', {
          default: false,
          describe: 'Creates a webpack-bundle-analyzer report for each bundle.',
          type: 'boolean',
        })
        .option('accurateBundles', {
          default: false,
          describe: 'Displays used bundles accurately at the cost of more CPU cycles.',
          type: 'boolean',
        });
    },
    handler: run,
  })
  .help()
  .strict(true)
  .version(false)
  .parse();
